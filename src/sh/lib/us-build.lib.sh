
us_build_lib__load ()
{
  : "${CACHE_DIR:=$HOME/.local/var/user-tools}"
  : "${US_CACHE_PREF:=us-preproc--}"
  : "${us_build_proc_dirs:=INCLUDE DEFINE MODELINE RESOLVE}"
  : "${us_build_init_dirs:=BUILD-PREPROC}"
  : "${us_build_run_dirs:=BUILD-RUN}"

  # Filter unhandled preproc statements from output
  #: "${us_preproc_filterdirs:=false}"
  # Auto-append all included files to generated target's us-build-files list.
  #: "${us_build_autorun:=true}"
}

us_build_lib__init ()
{
  test -z "${us_build_lib_init:-}" || return $_
  declare -ga us_build_files=()
  # For DEFINE
  declare -gA us_preproc_vardefs
  #declare -a us_preproc_vars

}


# Check for dev mode, build and fork to target script
us_exec ()
{
  local target=$1
  shift
  us_main_devenv
  us_build_v "$target" || return
  exec "$target"
}

# Return if target is up-to-date, or assemble new one in Cache-Dir
us_build () # ~ <Target> [<Cache-file>]
{
  local target=$1 tpl=$1.build ood cached
  : "${target%.sh}"
  cached="${2:-${CACHE_DIR:?}/${US_CACHE_PREF:?}${_//\//--}.spec.sh}"
  test 2 -ge $# || return ${_E_GAE:?}

  # Source meta for cached build, test if target is UTD. Otherwise
  # always try to regenerate.
  test -e "$target" -a -e "$cached" && {

    ! "${US_DEBUG:-false}" &&
      $LOG debug :build "Testing cached meta" "${cached%.spec.sh}.meta.sh"
    . "${cached%.spec.sh}.meta.sh" &&
    ! "${US_DEBUG:-false}" ||
      $LOG debug :build "Testing cached meta" \
        "${cached%.spec.sh}.meta.sh:(${#us_build_files[@]}):${us_build_files[*]// /:}"
    test 0 -lt "${#us_build_files[@]}" &&
    test "$target" -nt "$tpl" &&
    for file in "${us_build_files[@]}"
    do test "$target" -nt "$file" || { ood=true; break; }
    done
    ! ${ood:-false} && return
  }
  $LOG debug :us-run "(Re)generating script..." "$target"

  # Run preproc, body transform and run directives to generate file
  {
    { us_build_preproc "$tpl" &&
      $LOG debug :us-run "Preprocessing done" &&
      us_build_proc "$tpl" &&
      $LOG debug :us-run "Main processing done" &&
      us_build_run "$tpl"
    } >| "$target" || {
      rm "$target"
      return 3
    }
  }
  # &&

  # FIXME: move to run directives
  #if_ok "$(declare -p us_preproc_sources)" &&
  #echo "${_/#declare -a us_preproc_sources/declare -a files}" >| "$cached"
}

us_build__runline () # ~ <Rest>...
{
  fnmatch "* $dir *" " $procdirs " && {
    sh_fun us_preproc__${dir//[^A-Z0-9_]/_} ||
      $LOG alert : "No such directive" "$dir" 2 || return
    "$_" $* || return
  } || "${us_preproc_filterdirs:-false}" &&
    return ${_E_next:?} || return ${_E_ok:?}
}

us_build_dir () # ~ <Line-prefix> [...]
{
  test -n "${1:-}" &&
  fnmatch "#[A-Z_-]*" "${1^^}" && {
    : "${_:1}"
    #: "${_//[^A-Z0-9_]/_}"
    dir=${_^^}
  }
}

# Collect meta directives and generate script prologue with them
# Like the opposite 'run' this collects lines into an array, and then runs
# their each their handlers.
us_build_preproc () # ~ <File> [<Add-init-dirs>] [...]
{
  local l dir procdirs="${us_build_init_dirs:?}"
  test $# -gt 1 && {
    : "${*:2}"
    : "${_:?}"
    : "${_^^}"
    procdirs="$procdirs ${_//[^A-Z0-9_]/_}"
  }

  declare -ga us_build_preproc=()
  read -r -a us_build_preproc <<< "$(
    while read -r prefix rest
    do
      us_build_dir "$prefix" || continue
      echo "${prefix:-}${rest:+ }${rest:-}"
    done <<< "$(grep " ${procdirs// /\|} " "$1")")"
  $LOG debug :build:preproc "Found prologue directives" \
    "(${#us_build_preproc[*]})${us_build_preproc[*]:+ }${us_build_preproc[*]}"

  test 0 -lt "${#us_build_preproc[*]}" || us_build_preproc+=( "#build-preproc" )

  $LOG info :build:preproc "Generating initial script (prologue)" \
    "(${#us_build_preproc[*]})${us_build_preproc[*]:+ }${us_build_preproc[*]}"
  for l in "${us_build_preproc[@]}"
  do
    : "${l%% *}"
    : "${_#\#}"
    dir=${_^^}
    us_build__runline "$1" || {
      test ${_E_next:?} -eq $? && continue
      test ${_E_ok:?} -eq $_ ||
        $LOG error :build:preproc "Failed at" "E$_:$_" $? || return
    }
  done
}

# Output source with directives processed.
us_build_proc () # ~ <File> [<Additional-directives>...] [...]
{
  local prefix rest dir procdirs="${us_build_proc_dirs:?}"
  test $# -gt 1 && {
    : "${*:2}"
    : "${_:?}"
    : "${_^^}"
    procdirs="$procdirs ${_//[^A-Z0-9_]/_}"
  }
  echo "# Generated on $(date --iso=min) from $1"
  echo "# Do not edit this file"
  $LOG info :build:proc "Generating script body"
  while read -r prefix rest
  do
    us_build_dir "$prefix" && {
      us_build__runline "$rest" || {
        test ${_E_next:?} -eq $? && continue
        test ${_E_ok:?} -eq $_ || return
      }
      # Only proc selected directives, output others verbatim
    } || {
      fnmatch "##*" "$prefix" ||
        echo "${prefix:-}${rest:+ }${rest:-}"
    }
  done < "$1"
}

# Collect run directives and generate script epilogue with them.
# See also the opposite 'preproc'.
us_build_run () # ~ <File> [<Additional-directives>...] [...]
{
  local l dir procdirs="${us_build_run_dirs:?}"
  test $# -gt 1 && {
    : "${*:2}"
    : "${_:?}"
    : "${_^^}"
    procdirs="$procdirs ${_//[^A-Z0-9_]/_}"
  }

  declare -ga us_build_run
  read -r -a us_build_run <<< "$(
    while read -r prefix rest
    do
      us_build_dir "$prefix" || continue
      echo "${prefix:-}${rest:+ }${rest:-}"
    done <<< "$(grep " ${procdirs// /\|} " "$1")")"
  $LOG debug :build:run "Found run directives" \
    "(${#us_build_run[*]})${us_build_run[*]:+ }${us_build_run[*]}"

  test 0 -lt "${#us_build_run[*]}" || us_build_run+=( "#build-run" )

  $LOG info :build:run "Generating main run script (epilogue)" \
    "(${#us_build_run[*]})${us_build_run[*]:+ }${us_build_run[*]}"
  for l in "${us_build_run[@]}"
  do
    : "${l%% *}"
    : "${_#\#}"
    dir=${_^^}
    us_build__runline "$1" || {
      test ${_E_next:?} -eq $? && continue
      test ${_E_ok:?} -eq $_ ||
        $LOG error :build:run "Failed at" "E$_:$_" $? || return
    }
  done
}

us_build_v ()
{
  us_build "$@" ||
    $LOG alert :run "Script build failed" "E$?:$target" $? || return
}

us_preproc__BUILD_PREPROC ()
{
  us_build_files+=( "$1" )
  cat <<EOM
std_quiet declare -p us_build_files || declare -ga us_build_files
EOM
}

# Build and fork to script when executable bit is set, otherwise source.
# See us-run and us-exec.
us_main ()
{
  test -x "$t.sh" && {
    us_exec "$t.sh" "$@"
  }
  us_run "$t.sh" "$@"
}

# during development, add other script files to us_build_files
us_main_devenv ()
{
  str_globmatch " $SHMODE " "* dev*" || return 0
  us_build_files+=( "$0" )
  : "$(echo $ENV_LIB | tr ' ' '\n')"
  mapfile -O "${#us_build_files[@]}" -t us_build_files <<< "$_"
}

us_preproc__BUILD_RUN ()
{
  : "${1:?}"
  : "${_%.build}"
  : "${_%.sh}"
  local cached=${CACHE_DIR:?}/${US_CACHE_PREF:?}${_//\//--}.meta.sh
  $LOG debug :preproc:BUILD-RUN "Writing target meta cache" "$cached"
  "${us_build_autorun:-true}" && {
    set -- "${us_build_files[@]}"
  }
  { cat <<EOM
us_build_files+=( "$@" )
EOM
  } | tee "$cached"
}

us_preproc__DEFINE ()
{
  local var=${1:?} val=${2:?} # lk=${lk:+:us-preproc}:define
  declare -g us_preproc_vardefs[$var]=$val
  #us_preproc_vars+=( "$var" )
  eval "$var=$val"
}

us_preproc__INCLUDE ()
{
  local lk=${lk:+:us-preproc}:include
  false
}

us_preproc__MODELINE ()
{
  echo "# ex:ft=bash:"
}

us_preproc__RESOLVE ()
{
  local type=${1:?} rest=${*:2} lk=${lk:+:us-preproc}:resolve

  : "${type^^}"
  sh_fun us_preproc__RESOLVE_${_//[^A-Z0-9_]/_} ||
    $LOG alert : "No such sub-directive" "$dir" 2 || return
  $LOG debug :preproc "Resolve" "$_"
  "$_" $rest
}

us_preproc__RESOLVE_FUN ()
{
  local name=${1:?} ctx=${2:-} fun=${1//[^A-Za-z0-9_]/_}

  sh_fun "$fun" && ! "${us_preproc_forceload:-false}" ||
  test -z "$ctx" || {
    us_preproc_context "$ctx" &&
    uc_script_load "$name" &&
    if_ok "$(command -v "$name.${scr_ext:-sh}")" || return
    us_build_files+=( "$_" )
  }
  sh_fun "$fun" ||
    $LOG error "$lk:fun" "No such function" "$name" 2

  declare -f "$fun"
  # TODO: convert back to symbolic ref
  echo "# Copy: ${ctx_dir:-U-S}:$name"
}

us_preproc__RESOLVE_IF_FUN ()
{
  local fun=${1//[^A-Za-z0-9_]/_}
  echo "sh_fun $fun ||"
  us_preproc__RESOLVE_FUN "$@" | sed 's/^/  /'
}

us_preproc__RESOLVE_SCR ()
{
  local name=${1:?} ctx=${2:-} partid=${1//[^A-Za-z0-9_]/_}
  test -z "$ctx" ||
    us_preproc_context "$ctx" || return

  # FIXME: before caching all intermediate targets, need env specs build up first
  if_ok "$(command -v "$name.${scr_ext:-build}")" && {
    us_build "$_" || {
      $LOG error : "Resolving preprocessed script failed" "E$?:$_" $? || return
    }
    us_build_files+=( "$_" )
  } || {
    ! if_ok "$(command -v "$name.${scr_ext:-sh}")" || {
      cat "$_" || {
        $LOG error : "Reading script failed" "E$?:$_" $? || return
      }
      us_build_files+=( "$_" )
      # TODO: convert back to symbolic ref
      echo "# Copy: ${ctx_dir:-U-S}:$name"
    }
  }
}

us_preproc__RESOLVE_SCR_IF_FUN ()
{
  local fun=${1//[^A-Za-z0-9_]/_}
  echo "sh_fun $fun || {"
  us_preproc__RESOLVE_SCR "$@"
  echo "}"
}

us_preproc_context ()
{
  : "$(eval "echo \"${1:?}\"")"
  test -d "$_" ||
    $LOG error "$lk" "Unknown context type" "$_" 3 || return
  ctx_dir=$_
  PATH=$PATH:$ctx_dir
}

# Check for dev mode, build and source target script
us_run () # ~ <Target> [<Source-args...>]
{
  local target=$1
  shift
  us_main_devenv
  us_build_v "$target" || return
  . "$target"
}

# Id: U-S:us-build.lib
